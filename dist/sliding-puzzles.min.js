var SlidingPuzzles = function () {
  "use strict";

  function t(t, e) {
    return Math.abs(t - e);
  }
  function e(t, e) {
    return Math.floor(t / e);
  }
  function n(t, e) {
    return t % e;
  }
  function i(t, e, n) {
    return e * n + t;
  }
  function o(i, o, s) {
    return [i + o, i - o, i + 1, i - 1].filter(c => c >= 0 && c <= o * s && t(n(i, o), n(c, o)) <= 1 && t(e(i, o), e(c, o)) <= 1);
  }
  function s(t, e, n) {
    const o = Math.floor(t.width * (e[0] - n.left) / n.width),
      s = Math.floor(t.height * (e[1] - n.top) / n.height);
    return o >= 0 && o < t.width && s >= 0 && s < t.height ? i(o, s, t.width) : void 0;
  }
  function c(t, i) {
    const o = n(i, t.width),
      s = e(i, t.width);
    for (const i of t.pieces) if (n(i.position, t.width) <= o && n(i.position, t.width) + i.width > o && e(i.position, t.width) <= s && e(i.position, t.width) + i.height > s) return i;
  }
  function d(t, o, s, c) {
    const d = [];
    for (let r = n(o, t.width); r < n(o, t.width) + s; r++) for (let n = e(o, t.width); n < e(o, t.width) + c; n++) d.push(i(r, n, t.width));
    return d;
  }
  function r(t, e) {
    if (void 0 === t.selected || t.selected === e || t.config.solution(t) || !1 === t.config.movable) return !1;
    const n = c(t, t.selected);
    if (!n) return !1;
    const i = t.selected - e,
      s = n.position - i,
      r = d(t, n.position, n.width, n.height),
      h = d(t, s, n.width, n.height);
    return !(!r.some(n => o(n, t.width, t.height).includes(e)) || !h.every(e => e >= 0 && e < t.width * t.height) || h.some(e => t.occupied.includes(e) && !r.includes(e)));
  }
  function h(i, o) {
    if (void 0 === i.selected) return;
    const s = c(i, i.selected);
    if (!s) return;
    const r = s.position - (i.selected - o),
      h = d(i, s.position, s.width, s.height),
      u = d(i, r, s.width, s.height);
    var l, f, a;
    i.occupied = i.occupied.filter(t => !h.includes(t)), i.occupied.push(...u), i.moves += (l = s.position, f = r, a = i.width, t(n(l, a), n(f, a)) + t(e(l, a), e(f, a))), s.position = r;
  }
  function u(t) {
    t.elements.board.innerHTML = "";
    for (const i of t.pieces) {
      const o = document.createElement("sp-piece");
      o.classList.add(i.name), void 0 !== t.selected && d(t, i.position, i.width, i.height).includes(t.selected) && o.classList.add("selected"), o.style.transform = `translate(\n            ${n(i.position, t.width) * (100 / i.width)}%,${e(i.position, t.width) * (100 / i.height)}%\n        )`, o.style.width = 100 / t.width * i.width + "%", o.style.height = 100 / t.height * i.height + "%", t.config.specialEffect(i, o), t.elements.board.appendChild(o);
    }
    if (void 0 !== t.selected && t.config.showDests) {
      const i = function (t, e) {
        if (!e) return [];
        const n = d(t, e.position, e.width, e.height),
          i = JSON.parse(JSON.stringify(t));
        return i.config = t.config, i.selected = e.position, [...new Set(function t(e, n, i) {
          if (!n) return [];
          const s = [],
            u = d(e, n.position, n.width, n.height),
            l = u;
          for (const t of u) s.push(...o(t, e.width, e.height));
          i.push(n.position);
          for (const n of s) if (!i.includes(n) && r(e, n)) {
            const o = JSON.parse(JSON.stringify(e));
            o.config = e.config, h(o, n), o.selected = n, l.push(...t(o, c(o, o.selected), i));
          }
          return l;
        }(i, e, []).filter(t => !n.includes(t)))];
      }(t, c(t, t.selected));
      for (const o of i) {
        const i = document.createElement("sp-dest");
        i.style.transform = `translate(\n            ${100 * n(o, t.width)}%,${100 * e(o, t.width)}%\n        )`, i.style.width = 100 / t.width + "%", i.style.height = 100 / t.height + "%", t.elements.board.appendChild(i);
      }
    }
  }
  const l = t => {
    var e;
    return t.clientX || 0 === t.clientX ? [t.clientX, t.clientY] : (null === (e = t.targetTouches) || void 0 === e ? void 0 : e[0]) ? [t.targetTouches[0].clientX, t.targetTouches[0].clientY] : void 0;
  };
  function f(t, e, n) {
    t.addEventListener(n, t => {
      if (void 0 === e.selected || void 0 === e.pos) return;
      t.preventDefault();
      const n = l(t);
      if (n) {
        const t = s(e, n, e.elements.board.getBoundingClientRect()),
          d = (i = e.pos, o = n, [Math.abs(i[0] - o[0]), Math.abs(i[1] - o[1])]);
        void 0 !== t && t !== e.selected && (d[0] > 15 || d[1] > 15) && (r(e, t) ? (h(e, t), e.selected = t, e.pos = n, u(e), e.config.solution(e) && e.config.onVictory(e), e.config.onMove(e)) : c(e, e.selected) === c(e, t) && (e.selected = t));
      }
      var i, o;
    }, {
      once: !1
    });
  }
  function a(t, e, n) {
    t.addEventListener(n, () => {
      e.selected = void 0, e.pos = void 0, u(e);
    }, {
      once: !1
    });
  }
  return function (i, o, c) {
    const d = function (t) {
        t.innerHTML = "";
        const e = document.createElement("sp-main"),
          n = document.createElement("sp-board"),
          i = {
            main: e,
            board: n
          };
        return e.appendChild(n), t.appendChild(e), i;
      }(i),
      r = function (i, o, s) {
        const c = i.replace(/\n/g, "/").split("/").map(t => t.replace(/\s\s+/g, " ").trimEnd().trimStart()),
          d = c[0].split(" ").length,
          r = c.length,
          h = [],
          u = new Map();
        let l = 0;
        for (const t of c) for (const e of t.split(" ")) "." == e ? l += 1 : (u.set(l, e), l++);
        const f = new Set();
        function a(i) {
          const o = [i];
          for (const s of [i + d, i + 1].filter(o => o <= d * r && t(n(i, d), n(o, d)) <= 1 && t(e(i, d), e(o, d)) <= 1)) f.has(s) || u.get(s) !== u.get(i) || (f.add(s), o.push(...a(s)));
          return o;
        }
        for (const i of u) if (!f.has(i[0])) {
          const o = a(i[0]);
          h.push({
            name: i[1],
            position: i[0],
            width: t(n(i[0], d), n(Math.max(...o), d)) + 1,
            height: t(e(i[0], d), e(Math.max(...o), d)) + 1
          });
        }
        return {
          pieces: h,
          occupied: Array.from(u.keys()),
          moves: 0,
          width: d,
          height: r,
          elements: o,
          config: s
        };
      }(o, d, Object.assign({}, {
        solution: () => !1,
        onMove: () => {},
        specialEffect: () => {},
        onVictory: () => {},
        movable: !0,
        showDests: !1
      }, c));
    return u(r), function (t) {
      for (const e of ["touchstart", "mousedown"]) t.elements.main.addEventListener(e, n => {
        if (!n.isTrusted || void 0 !== n.button && 0 !== n.button) return;
        if (n.touches && n.touches.length > 1) return;
        n.preventDefault(), "touchstart" === e && n.target && (f(n.target, t, "touchmove"), a(n.target, t, "touchend"));
        const i = l(n);
        if (i) {
          const e = s(t, i, t.elements.board.getBoundingClientRect());
          t.selected = e, t.pos = i, u(t);
        }
      }, {
        passive: !1
      });
      f(document, t, "mousemove"), a(document, t, "mouseup"), t.elements.main.addEventListener("contextmenu", t => {
        t.preventDefault();
      });
    }(r), {
      situation: r
    };
  };
}();
